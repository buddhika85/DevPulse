# Trigger the pipeline when code is pushed to the 'main' branch
trigger:
  branches:
    include:
      - main

# Define reusable variables for ACR, ACA, and deployment settings
variables:
  # ACR name (NOT the login server). Required by `az acr build --registry`
  acrName: devpulseacr-cta8h8feeua4cchz

  # ACR Login server (used when referencing the final image)
  acrLoginServer: devpulseacr-cta8h8feeua4cchz.azurecr.io

  imageName: orchestrator-api                 # Docker image name
  resourceGroup: DevPulseRG                   # Azure resource group
  containerAppName: orchestrator-api          # Azure Container App name
  location: australiaeast                     # Azure region

  # IMPORTANT:
  # Use a UNIQUE tag for every build to force ACA to pull the new image. 
  # - 20251220-174855-1234
  # - Date → 20251220
  # - Time → 17:48:55
  # - Build ID → 1234
  # Build.BuildId is guaranteed unique per pipeline run.
  tag: $(Date:yyyyMMdd-HHmmss)-$(Build.BuildId)

# Use a Microsoft-hosted Ubuntu agent to run the pipeline
pool:
  vmImage: ubuntu-latest

# Define the pipeline steps
steps:
  # Step 1: Build and push the image using ACR build service
  # Using ACR Build avoids Docker installation issues and DNS problems on DevOps agents.
  - task: AzureCLI@2
    displayName: 'Build via ACR and Deploy to ACA'
    inputs:
      azureSubscription: 'DevPulse-SP-AzContainerReg-ACA'  # Azure service connection name configured in Azure DevOps
      scriptType: bash
      scriptLocation: inlineScript
      failOnStderr: true                                   # Fail the task if any CLI command throws an error
      inlineScript: |
        echo "Building and pushing image via ACR..."

        # IMPORTANT:
        # --file points to the Dockerfile inside the OrchestratorService folder.
        # The final argument (backend/OrchestratorService) is the build context.
        # $(tag) ensures each build produces a NEW image version.
        az acr build \
          --registry $(acrName) \
          --image $(imageName):$(tag) \
          --file backend/OrchestratorService/Dockerfile \
          backend/OrchestratorService

        echo "Deploying to Azure Container Apps..."

        # IMPORTANT:
        # --revision-suffix forces ACA to create a NEW revision.
        # This guarantees ACA pulls the new image instead of reusing cached ones.
        az containerapp update \
          --name $(containerAppName) \
          --resource-group $(resourceGroup) \
          --image $(acrLoginServer)/$(imageName):$(tag) \
          --revision-suffix $(tag)

  # Step 2: Warm up the ACA endpoint to avoid cold start latency
  # This ensures the service is responsive immediately after deployment.
  - script: |
      echo "Warming up OrchestratorService..."
      for i in {1..10}; do
        response=$(curl -s -o /dev/null -w "%{http_code}" https://orchestrator-api.yellowcoast-35d1851f.australiasoutheast.azurecontainerapps.io/api/Health)
        echo "Attempt $i: HTTP $response"
        if [ "$response" -eq 200 ]; then
          echo "Success - Service is warm."
          break
        fi
        sleep 5
      done
    displayName: 'Warm up OrchestratorService after deploy'
    condition: succeeded()  # Only run this step if the previous deployment succeeded