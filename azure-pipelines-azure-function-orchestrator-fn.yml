# Run this pipeline when code is pushed to main
trigger:
  branches:
    include:
      - main

# Use Ubuntu agent for compatibility
pool:
  vmImage: "ubuntu-latest"

# Define variables
variables:
  - group: DevPulse-Backend-Secrets # Inject ServiceBusConnectionString and HealthCheckAzureFunctionUrl
  - name: buildConfiguration
    value: "Release"
  - name: functionProjectPath
    value: "backend/AzureFunctions/DevPulseOrchestratorFn/DevPulseOrchestratorFn.csproj"
  - name: publishOutput
    value: "$(Build.ArtifactStagingDirectory)/publish"
  - name: functionOutput
    value: "$(publishOutput)/DevPulseOrchestratorFn"

# Build and deploy stage
stages:
  - stage: BuildAndDeployFunction
    displayName: "Build and Deploy Azure Function"
    jobs:
      - job: BuildAndDeploy
        displayName: "Build and Deploy Job"
        steps:
          # Step 1: Install .NET 8 SDK
          - task: UseDotNet@2
            displayName: "Install .NET 8 SDK"
            inputs:
              packageType: "sdk"
              version: "8.x"

          # Step 2: Build and publish the function project
          - task: DotNetCoreCLI@2
            displayName: "Publish Azure Function"
            inputs:
              command: "publish"
              publishWebProjects: false
              projects: "$(functionProjectPath)"
              arguments: "--configuration $(buildConfiguration) --output $(publishOutput)"
              zipAfterPublish: false

          # Step 3: Check that required files exist before deployment
          - script: |
              echo "Checking contents of: $(functionOutput)"
              ls -la "$(functionOutput)"

              if [ ! -f "$(functionOutput)/host.json" ]; then
                echo "‚ùå host.json not found. Deployment will fail."
                exit 1
              fi

              if [ ! -f "$(functionOutput)/functions.metadata" ]; then
                echo "‚ùå functions.metadata not found. Function will not be recognized."
                exit 1
              fi

              echo "‚úÖ Required files found. Proceeding with deployment."
            displayName: "Validate publish output"

          # Step 4: Deploy to Azure Function App
          - task: AzureFunctionApp@2
            displayName: "Deploy to Azure Function App"
            inputs:
              azureSubscription: "DevPulse-Azure-Connection"
              appType: "functionApp"
              appName: "devpulsefunctionapp"
              package: "$(functionOutput)"
              deploymentMethod: "zipDeploy"

          # Step 4A: Warm up Function App using health check endpoint
          - task: Bash@3
            displayName: "Warm up Function App with health ping"
            inputs:
              targetType: "inline"
              script: |
                echo "üîÑ Sending health ping to warm up Function App..."
                echo "Health URL: $(HealthCheckAzureFunctionUrl)"
                curl -s "$(HealthCheckAzureFunctionUrl)" || echo "‚ö†Ô∏è Health ping failed (non-blocking)"
                echo "‚úÖ Health ping sent. Proceeding to message dispatch..."

          # Step 5: Send test message to Service Bus topic
          - task: Bash@3
            displayName: "Send test message to Service Bus"
            inputs:
              targetType: "inline"
              script: |
                set -e
                connectionString="$(ServiceBusConnectionString)"
                tempPath="$(Build.ArtifactStagingDirectory)/sbSender"
                mkdir -p "$tempPath"
                cd "$tempPath"
                dotnet new console --framework net8.0 --output . > /dev/null
                dotnet add package Azure.Messaging.ServiceBus --version 7.16.1 > /dev/null

                echo 'using System;' > Program.cs
                echo 'using System.Threading.Tasks;' >> Program.cs
                echo 'using Azure.Messaging.ServiceBus;' >> Program.cs
                echo '' >> Program.cs
                echo 'class Program {' >> Program.cs
                echo '    static async Task Main() {' >> Program.cs
                echo '        var conn = Environment.GetEnvironmentVariable("SB_CONN");' >> Program.cs
                echo '        var topic = "user-updates";' >> Program.cs
                echo '        var body = "{\"UserId\":\"a1b2c3d4-e5f6-7890-abcd-1234567890ef\",\"UpdateField\":\"All\",\"Message\":\"Published via CI/CD for testing : User updated\",\"TimeStamp\":\"" + DateTime.UtcNow.ToString("o") + "\"}";' >> Program.cs
                echo '        var client = new ServiceBusClient(conn);' >> Program.cs
                echo '        var sender = client.CreateSender(topic);' >> Program.cs
                echo '        var message = new ServiceBusMessage(body);' >> Program.cs
                echo '        await sender.SendMessageAsync(message);' >> Program.cs
                echo '        Console.WriteLine("‚úÖ Test message sent to Azure Service Bus Topic - User Updates.");' >> Program.cs
                echo '    }' >> Program.cs
                echo '}' >> Program.cs

                export SB_CONN="$connectionString"
                dotnet run

          # Step 6: Verify function execution by downloading and scanning latest log file
          - task: AzureCLI@2
            displayName: "Verify function execution via log download"
            inputs:
              azureSubscription: "DevPulse-Azure-Connection"
              scriptType: "bash"
              scriptLocation: "inlineScript"
              inlineScript: |
                echo "‚è≥ Waiting 180 seconds for function to process the message..."
                sleep 180

                echo "üì• Downloading logs from Function App..."
                az webapp log download \
                  --name devpulsefunctionapp \
                  --resource-group DevPulseRG \
                  --output zip \
                  --output-file function_logs.zip

                unzip -o function_logs.zip -d logs

                echo "üìÅ Identifying latest log file..."
                latestLog=$(find logs/LogFiles/Application/ -type f -name "*.txt" -printf "%T@ %p\n" | sort -n | tail -1 | cut -d' ' -f2)

                echo "üîç Searching for execution markers in: $latestLog"
                if grep -q "UserUpdatedHandlerAzureFunction - Received message" "$latestLog" && \
                   grep -q "Cache invalidation triggered for UserId:" "$latestLog"; then
                  echo "‚úÖ Function executed and cache invalidation confirmed."
                else
                  echo "‚ùå Expected log markers not found. Function may not have triggered or failed silently."
                  exit 1
                fi
